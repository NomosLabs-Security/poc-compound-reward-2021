// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Compound — Simplified COMP Distribution Bug
/// @notice Educational simulation of the Proposal 062 bug that caused
///         excessive COMP token distribution due to state index reset.

import "./MockERC20.sol";

contract SimplifiedComptroller {
    // COMP token
    MockERC20 public comp;

    // Market state tracking
    struct CompMarketState {
        uint224 index;    // Accumulated COMP per unit
        uint32 block_;    // Last updated block
    }

    // Initial index value (1e36)
    uint224 public constant COMP_INITIAL_INDEX = 1e36;

    // Market → state
    mapping(address => CompMarketState) public compSupplyState;
    // Market → speed (COMP per block)
    mapping(address => uint256) public compSpeeds;
    // Market → user → index
    mapping(address => mapping(address => uint256)) public compSupplierIndex;
    // User → accrued COMP
    mapping(address => uint256) public compAccrued;

    // Simulated total supply per market
    mapping(address => uint256) public marketTotalSupply;
    // User balances per market
    mapping(address => mapping(address => uint256)) public marketBalances;

    event CompDistributed(address indexed market, uint256 newIndex, uint256 blockNumber);
    event CompClaimed(address indexed user, uint256 amount);

    constructor(address _comp) {
        comp = MockERC20(_comp);
    }

    /// @notice Add a market with initial state
    function addMarket(address market, uint256 speed) external {
        compSupplyState[market] = CompMarketState({
            index: COMP_INITIAL_INDEX,
            block_: safe32(block.number)
        });
        compSpeeds[market] = speed;
    }

    /// @notice Simulate user depositing into a market
    function simulateDeposit(address market, address user, uint256 amount) external {
        // Update supplier index to current
        compSupplierIndex[market][user] = compSupplyState[market].index;
        marketBalances[market][user] += amount;
        marketTotalSupply[market] += amount;
    }

    /// @notice Update distribution index for a market
    function updateCompSupplyIndex(address market) public {
        CompMarketState storage state = compSupplyState[market];
        uint256 speed = compSpeeds[market];
        uint256 blockDelta = block.number - state.block_;

        if (blockDelta > 0 && speed > 0 && marketTotalSupply[market] > 0) {
            uint256 compAccrued_ = blockDelta * speed;
            uint256 ratio = (compAccrued_ * 1e18) / marketTotalSupply[market];
            uint224 newIndex = state.index + uint224(ratio);
            state.index = newIndex;
            state.block_ = safe32(block.number);
            emit CompDistributed(market, newIndex, block.number);
        }
    }

    /// @notice VULNERABLE — Proposal 062 bug simulation
    /// @dev Resets index to COMP_INITIAL_INDEX when speed changes,
    ///      losing accumulated distribution state
    function setCompSpeedBuggy(address market, uint256 newSpeed) external {
        // Bug: treats existing market as new if speed was 0
        if (compSpeeds[market] == 0 && newSpeed > 0) {
            // ❌ BUG: Resets index, erasing accumulated rewards
            compSupplyState[market] = CompMarketState({
                index: COMP_INITIAL_INDEX,  // Reset to initial!
                block_: safe32(block.number)
            });
        }
        compSpeeds[market] = newSpeed;
    }

    /// @notice FIXED version — preserves existing state
    function setCompSpeedFixed(address market, uint256 newSpeed) external {
        if (compSupplyState[market].index == 0 && compSupplyState[market].block_ == 0) {
            // ✅ Only initialize truly new markets
            compSupplyState[market] = CompMarketState({
                index: COMP_INITIAL_INDEX,
                block_: safe32(block.number)
            });
        }
        compSpeeds[market] = newSpeed;
    }

    /// @notice Claim COMP for a user across markets
    function claimComp(address user, address[] memory markets) external {
        for (uint256 i = 0; i < markets.length; i++) {
            updateCompSupplyIndex(markets[i]);
            _distributeSupplierComp(markets[i], user);
        }

        uint256 amount = compAccrued[user];
        if (amount > 0) {
            compAccrued[user] = 0;
            comp.transfer(user, amount);
            emit CompClaimed(user, amount);
        }
    }

    function _distributeSupplierComp(address market, address user) internal {
        uint256 supplyIndex = compSupplyState[market].index;
        uint256 supplierIndex = compSupplierIndex[market][user];

        compSupplierIndex[market][user] = supplyIndex;

        if (supplierIndex > 0) {
            uint256 deltaIndex = supplyIndex - supplierIndex;
            uint256 supplierTokens = marketBalances[market][user];
            uint256 supplierDelta = (supplierTokens * deltaIndex) / 1e18;
            compAccrued[user] += supplierDelta;
        }
    }

    function safe32(uint256 n) internal pure returns (uint32) {
        require(n < 2**32, "safe32");
        return uint32(n);
    }
}
