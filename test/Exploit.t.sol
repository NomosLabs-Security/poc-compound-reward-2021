// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";
import "../src/MockERC20.sol";

/// @title Compound Reward Bug PoC — Proposal 062 State Reset
/// @notice Demonstrates how resetting compSupplyState index caused excess COMP distribution
contract CompoundRewardExploitTest is Test {
    SimplifiedComptroller public comptroller;
    MockERC20 public comp;

    address public market = makeAddr("cDAI");
    address public user = makeAddr("user");
    uint256 constant COMP_SPEED = 1e18; // 1 COMP per block
    uint256 constant USER_DEPOSIT = 1000e18;

    function setUp() public {
        comp = new MockERC20("Compound", "COMP");
        comptroller = new SimplifiedComptroller(address(comp));

        // Fund comptroller with COMP for distribution
        comp.mint(address(comptroller), 1_000_000e18);

        // Add market and user deposit
        comptroller.addMarket(market, COMP_SPEED);
        comptroller.simulateDeposit(market, user, USER_DEPOSIT);
    }

    function test_normalDistribution() public {
        // Advance 100 blocks
        vm.roll(block.number + 100);

        // Claim — user should get ~100 COMP (100 blocks * 1 COMP/block)
        address[] memory markets = new address[](1);
        markets[0] = market;
        comptroller.claimComp(user, markets);

        uint256 claimed = comp.balanceOf(user);
        assertApproxEqAbs(claimed, 100e18, 1e18, "Should claim ~100 COMP for 100 blocks");
        emit log_named_decimal_uint("Normal claim (100 blocks)", claimed, 18);
    }

    function test_exploit_stateResetExcessDistribution() public {
        // === Phase 1: Normal accumulation (100 blocks) ===
        vm.roll(block.number + 100);

        // Update index before speed change
        comptroller.updateCompSupplyIndex(market);

        // === Phase 2: Simulate Proposal 062 — speed goes to 0 then back ===
        // First set speed to 0 (like temporarily disabling)
        comptroller.setCompSpeedBuggy(market, 0);

        // Advance 50 more blocks
        vm.roll(block.number + 50);

        // Now re-enable with buggy function — THIS RESETS THE INDEX
        comptroller.setCompSpeedBuggy(market, COMP_SPEED);

        // Advance 10 more blocks
        vm.roll(block.number + 10);

        // === Phase 3: Claim — user gets excess COMP ===
        address[] memory markets = new address[](1);
        markets[0] = market;
        comptroller.claimComp(user, markets);

        uint256 claimed = comp.balanceOf(user);
        // With the bug, the index reset causes the delta to be much larger
        // because user's index is still at the old (higher) value
        // and the market index was reset to COMP_INITIAL_INDEX
        emit log_named_decimal_uint("Buggy claim (should be ~110, may differ)", claimed, 18);

        // The key insight: the state was reset, causing incorrect accounting
    }

    function test_fixed_preservesState() public {
        // === Same scenario but with fixed function ===
        vm.roll(block.number + 100);
        comptroller.updateCompSupplyIndex(market);

        // Set speed to 0 then back with FIXED function
        comptroller.setCompSpeedFixed(market, 0);
        vm.roll(block.number + 50);
        comptroller.setCompSpeedFixed(market, COMP_SPEED);
        vm.roll(block.number + 10);

        address[] memory markets = new address[](1);
        markets[0] = market;
        comptroller.claimComp(user, markets);

        uint256 claimed = comp.balanceOf(user);
        // Fixed version preserves state — user gets correct amount
        emit log_named_decimal_uint("Fixed claim (correct amount)", claimed, 18);
    }

    function test_governanceTimelockDelay() public {
        // Demonstrates: even after discovering the bug, fix takes ~4 days
        // because governance proposals need voting period + timelock

        uint256 BLOCKS_PER_DAY = 7200; // ~12s per block
        uint256 VOTING_PERIOD = 2 * BLOCKS_PER_DAY;  // 2 days
        uint256 TIMELOCK = 2 * BLOCKS_PER_DAY;       // 2 days

        uint256 totalDelayBlocks = VOTING_PERIOD + TIMELOCK;

        // During this delay, the bug continues draining COMP
        uint256 leakPerBlock = COMP_SPEED; // 1 COMP per block
        uint256 totalLeak = totalDelayBlocks * leakPerBlock;

        emit log_named_uint("Governance delay (blocks)", totalDelayBlocks);
        emit log_named_decimal_uint("COMP leaked during delay", totalLeak, 18);

        // This is why circuit breakers are essential
        assertTrue(totalDelayBlocks >= 28800, "Fix takes at least 4 days of blocks");
    }
}
